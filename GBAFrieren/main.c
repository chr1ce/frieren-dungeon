#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "player.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/blokita.h"
#include "images/frieren.h"
#include "images/startImage.h"
#include "images/frierenInMimic.h"
#include "images/chest.h"
#include "images/frierenCelebration.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  Player player = createPlayer();
  Chest chest1 = createChest(80, 65, 1, 0);
  Chest chest2 = createChest(115, 65, 1, 0);
  Chest chest3 = createChest(150, 65, 1, 1);
  Chest chests[] = {chest1, chest2, chest3};


  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  int frameCount = 0;

  char scoreStr[20];
  char healthStr[20];
  int oldScore;
  int oldHealth;

  char *introStr = "Frieren Dungeon";
  waitForVBlank();
  drawFullScreenImageDMA(startImage);

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    
    switch (state) {
      case START:
        waitForVBlank();
        drawCenteredString(30, 110, 20, 20, introStr, WHITE);
        if ((frameCount % 2) == 0) {
          drawCenteredString(80, 115, 10, 10, "Press START:", BLACK);
        } else {
          undrawImageDMA(80, 115, 60, 8, startImage);
        }

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          waitForVBlank();
          fillScreenDMA(BLACK);
          for (int i = 0; i < 3; i++) {
            //Randomize mimic status of chests
            if ((randint(0, 4096) & 2) == 2) {
              chests[i].isMimic = 1;
            } else {
              chests[i].isMimic = 0;
            }
            waitForVBlank();
            drawImageDMA(chests[i].y, chests[i].x, 16, 16, chest);
          }
          state = PLAY;

        }

        break;
      case PLAY:
        oldScore = player.score;
        oldHealth = player.health;
        snprintf(scoreStr, 20, "Score: %d", player.score);
        snprintf(healthStr, 20, "Health: %d", player.health);
        
        drawString(5, 5, scoreStr, WHITE);
        drawString(5, 160, healthStr, WHITE);


        waitForVBlank();
        drawRectDMA(player.y, player.x, FRIEREN_WIDTH, FRIEREN_HEIGHT, BLACK);

        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          player.velY = -PLAYER_SPEED;
          player.velX = 0;
        } else if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          player.velY = PLAYER_SPEED;
          player.velX = 0;
        } else if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          player.velX = -PLAYER_SPEED;
          player.velY = 0;
        } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          player.velX = PLAYER_SPEED;
          player.velY = 0;
        } else {
          player.velY = 0;
          player.velX = 0;
        }

        for (int i = 0; i < 3; i++) {
          if (collides(chests[i].x, chests[i].y, player.x + player.velX, player.y + player.velY, 16, 16, 16, 16)) {
            player.velX = 0;
            player.velY = 0;
          }
        }

        player.x += player.velX;
        player.y += player.velY;

        for (int i = 0; i < 3; i++) {
          if (canSelect(chests[i], player)) {
              if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
                if (!chests[i].isMimic) {
                    player.score += chests[i].value;
                } else {
                    player.health--;
                }
                for (int i = 0; i < 3; i++) {
                  if ((randint(0, 4096) & 2) == 2) {
                    chests[i].isMimic = 1;
                  } else {
                    chests[i].isMimic = 0;
                  }
                }
                
              }
          }
        }


        drawImageDMA(player.y, player.x, FRIEREN_WIDTH, FRIEREN_HEIGHT, frieren);

        if (oldHealth != player.health) {
          drawRectDMA(5, 209, 5, 7, BLACK);
        }
        if (oldScore != player.score) {
          drawRectDMA(5, 48, 5, 7, BLACK);
        }

        if (player.score >= 5) {
          waitForVBlank();
          drawFullScreenImageDMA(frierenCelebration);
          state = WIN;
        }
        if (player.health <= 0) {
          waitForVBlank();
          drawFullScreenImageDMA(frierenInMimic);
          state = LOSE;
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, BUTTONS, previousButtons)) {
          waitForVBlank();
          drawFullScreenImageDMA(startImage);
          state = START;

        }
        break;
      case WIN:
        waitForVBlank();
        drawCenteredString(64, 120, 20, 20, "You Won! Play again with SELECT.", WHITE);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, BUTTONS, previousButtons)) {
          player.score = 0;
          player.health = INIT_HEALTH;
          player.x = INIT_X;
          player.y = INIT_Y;
          waitForVBlank();
          drawFullScreenImageDMA(startImage);
          state = START;

        }
        break;
      case LOSE:
        waitForVBlank();
        drawCenteredString(64, 120, 20, 20, "You Lost: Play again with SELECT.", WHITE);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, BUTTONS, previousButtons)) {
          player.score = 0;
          player.health = INIT_HEALTH;
          player.x = INIT_X;
          player.y = INIT_Y;
          waitForVBlank();
          drawFullScreenImageDMA(startImage);
          state = START;

        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}

Chest createChest(int x, int y, int value, int isMimic) {
  Chest newChest;
  newChest.x = x;
  newChest.y = y;
  newChest.value = value;
  newChest.isMimic = isMimic;
  return newChest;
}

int canSelect(Chest c, Player player) {
  return collides(c.x, c.y, player.x, player.y, SPRITE_SIZE, SPRITE_SIZE + 5, SPRITE_SIZE, SPRITE_SIZE);
}

int collides(int x1, int y1, int x2, int y2, int width1, int height1, int width2, int height2) {
  if ((((x1 + width1) > (x2))
  && ((x1) < (x2 + width2)))
  && (((y1 + height1) > (y2))
  && ((y1) < (y2 + height2)))) {
    return 1;
  }
  return 0;
}

// int useChest(Chest chest, Player player) {
//     if (!chest.isMimic) {
//         player.score += chest.value;
//     } else {
//         player.health--;
//     }
//     if ((randint(0, 256) & 2) == 2) {
//         chest.isMimic = 1;
//     } else {
//       chest.isMimic = 0;
//     }
//     return player.score;
// }

